<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bloco de Notas Avançado</title>
  <style>
    :root {
      --bg-color: #1e1e2e;
      --header-bg: #181825;
      --tab-bg: #313244;
      --tab-active: #1e1e2e;
      --text-color: #cdd6f4;
      --accent-color: #89b4fa;
      --border-color: #45475a;
      --popup-bg: #313244;
      --highlight-color: rgba(137, 180, 250, 0.2);
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', 'Arial', sans-serif;
    }
    
    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .header {
      background-color: var(--header-bg);
      padding: 8px;
      display: flex;
      align-items: center;
      border-bottom: 1px solid var(--border-color);
    }
    
    .app-title {
      font-size: 14px;
      margin-right: 20px;
      color: var(--accent-color);
    }
    
    .tabs-container {
      display: flex;
      flex-grow: 1;
      overflow-x: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--accent-color) var(--header-bg);
    }
    
    .tabs-container::-webkit-scrollbar {
      height: 4px;
    }
    
    .tabs-container::-webkit-scrollbar-thumb {
      background-color: var(--accent-color);
      border-radius: 4px;
    }
    
    .tab {
      padding: 8px 16px;
      background-color: var(--tab-bg);
      margin-right: 4px;
      border-radius: 4px 4px 0 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      white-space: nowrap;
      transition: all 0.2s ease;
      border: 1px solid transparent;
    }
    
    .tab.active {
      background-color: var(--tab-active);
      border-bottom: 2px solid var(--accent-color);
    }
    
    .tab-title {
      margin-right: 8px;
    }
    
    .tab-title-editable {
      outline: none;
      border: none;
      background: transparent;
      color: inherit;
      font-size: inherit;
      padding: 0;
      min-width: 80px;
    }
    
    .tab-title-editable:focus {
      border-bottom: 1px dashed var(--accent-color);
    }
    
    .close-tab {
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      opacity: 0.6;
      transition: all 0.2s;
    }
    
    .close-tab:hover {
      background-color: rgba(255, 255, 255, 0.1);
      opacity: 1;
    }
    
    .new-tab-btn {
      background: none;
      border: none;
      color: var(--text-color);
      font-size: 20px;
      cursor: pointer;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      margin-left: 8px;
    }
    
    .new-tab-btn:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    .editor-container {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
    }
    
    .editor {
      flex-grow: 1;
      padding: 16px;
      background-color: var(--bg-color);
      outline: none;
      font-size: 16px;
      line-height: 1.6;
      caret-color: var(--accent-color);
      display: none;
      overflow-y: auto;
      opacity: 1;
      transition: opacity 0.3s ease;
    }
    
    .editor.active {
      display: block;
    }
    
    .editor:focus {
      border: none;
      outline: none;
    }
    
    .editor::-webkit-scrollbar {
      width: 8px;
    }
    
    .editor::-webkit-scrollbar-thumb {
      background-color: var(--border-color);
      border-radius: 4px;
    }
    
    .format-popup {
      position: absolute;
      background-color: var(--popup-bg);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      padding: 10px;
      z-index: 10;
      display: none;
      animation: fadeIn 0.2s ease;
      border: 1px solid var(--border-color);
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .format-section {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .format-section:last-child {
      margin-bottom: 0;
    }
    
    .format-label {
      font-size: 12px;
      margin-right: 10px;
      min-width: 60px;
    }
    
    .format-buttons {
      display: flex;
      gap: 5px;
    }
    
    .format-btn {
      background: none;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-color);
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .format-btn:hover, .format-btn.active {
      background-color: var(--accent-color);
      color: var(--bg-color);
    }
    
    .format-select {
      background-color: var(--tab-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
    }
    
    .id-input {
      background-color: var(--tab-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 4px 8px;
      width: 80px;
    }
    
    .status-bar {
      background-color: var(--header-bg);
      padding: 4px 16px;
      font-size: 12px;
      border-top: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
    }

    .faded, .normal {
      transition: opacity 0.3s ease;
    }

    .faded {
      opacity: 0.4 !important;
    }

    .normal {
      opacity: 1 !important;
    }
    
    [contenteditable=true]:empty:before {
      content: attr(placeholder);
      color: rgba(205, 214, 244, 0.5);
      pointer-events: none;
    }

    .editor-container {
      position: relative;
    }

    .editor-with-line-numbers {
      padding-left: 48px !important;
    }

    .line-numbers {
      position: absolute;
      top: 0;
      left: 0;
      width: 40px;
      height: 100%;
      padding: 16px 0;
      background-color: var(--header-bg);
      color: var(--border-color);
      font-size: 12px;
      text-align: right;
      border-right: 1px solid var(--border-color);
      user-select: none;
      overflow: hidden;
      z-index: 1;
      pointer-events: none;
    }

    .line-number {
      padding: 0 8px;
      height: 24px;
      line-height: 24px;
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .status-left, .status-right {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .status-btn {
      background: none;
      border: none;
      color: var(--text-color);
      cursor: pointer;
      padding: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
    }

    .status-btn:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="app-title">Bloco de Notas</div>
    <div class="tabs-container" id="tabs-container"></div>
    <button class="new-tab-btn" id="new-tab-btn" title="Nova aba">+</button>
  </div>
  
  <div class="editor-container" id="editor-container">
    <div class="format-popup" id="format-popup">
      <div class="format-section">
        <div class="format-label">Estilo</div>
        <div class="format-buttons">
          <button class="format-btn" id="bold-btn" title="Negrito">B</button>
          <button class="format-btn" id="italic-btn" title="Itálico">I</button>
          <button class="format-btn" id="underline-btn" title="Sublinhado">U</button>
        </div>
      </div>
      
      <div class="format-section">
        <div class="format-label">Fonte</div>
        <select class="format-select" id="font-select">
          <option value="'Segoe UI', 'Arial', sans-serif">Segoe UI</option>
          <option value="'Arial', sans-serif">Arial</option>
          <option value="'Times New Roman', serif">Times New Roman</option>
          <option value="'Courier New', monospace">Courier New</option>
          <option value="'Georgia', serif">Georgia</option>
        </select>
      </div>
      
      <div class="format-section">
        <div class="format-label">Tamanho</div>
        <select class="format-select" id="size-select">
          <option value="12px">12px</option>
          <option value="14px">14px</option>
          <option value="16px" selected>16px</option>
          <option value="18px">18px</option>
          <option value="20px">20px</option>
          <option value="24px">24px</option>
        </select>
      </div>
      
      <div class="format-section">
        <div class="format-label">Cor</div>
        <input type="color" class="format-btn" id="color-picker" value="#cdd6f4">
      </div>
      
      <div class="format-section">
        <div class="format-label">ID</div>
        <input type="number" class="id-input" id="id-input" min="0" placeholder="ID">
      </div>
    </div>
  </div>

  <div class="status-bar">
    <div class="status-left">
      <div id="cursor-position">Ln: 1, Col: 1</div>
      <div id="current-id">ID: 0</div>
    </div>
    <div class="status-right">
      <!-- Movido os botões para cá -->
      <button id="text-inversion-btn" class="status-btn" title="Inversão Textual">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M9 5H2v7M15 19h7v-7"></path>
          <path d="M2 12v7h7"></path>
          <path d="M22 12V5h-7"></path>
        </svg>
      </button>
      <button id="copy-formatted-btn" class="status-btn" title="Copiar Texto com Formatação">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
        </svg>
      </button>
      <button id="line-numbers-btn" class="status-btn" title="Mostrar/Ocultar Numeração de Linhas">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="9" y1="4" x2="20" y2="4"></line>
          <line x1="9" y1="8" x2="20" y2="8"></line>
          <line x1="9" y1="12" x2="20" y2="12"></line>
          <line x1="9" y1="16" x2="20" y2="16"></line>
          <line x1="9" y1="20" x2="20" y2="20"></line>
          <line x1="5" y1="4" x2="5" y2="4"></line>
          <line x1="5" y1="8" x2="5" y2="8"></line>
          <line x1="5" y1="12" x2="5" y2="12"></line>
          <line x1="5" y1="16" x2="5" y2="16"></line>
          <line x1="5" y1="20" x2="5" y2="20"></line>
        </svg>
      </button>
    </div>
  </div>

  <script>
     document.addEventListener('DOMContentLoaded', function() {
      const tabsContainer = document.getElementById('tabs-container');
      const editorContainer = document.getElementById('editor-container');
      const newTabBtn = document.getElementById('new-tab-btn');
      const formatPopup = document.getElementById('format-popup');
      const boldBtn = document.getElementById('bold-btn');
      const italicBtn = document.getElementById('italic-btn');
      const underlineBtn = document.getElementById('underline-btn');
      const fontSelect = document.getElementById('font-select');
      const sizeSelect = document.getElementById('size-select');
      const colorPicker = document.getElementById('color-picker');
      const idInput = document.getElementById('id-input');
      const cursorPosition = document.getElementById('cursor-position');
      const currentIdDisplay = document.getElementById('current-id');
      const lineNumbersBtn = document.getElementById('line-numbers-btn');

      let showLineNumbers = false;
      let tabs = [];
      let activeTabIndex = -1;
      let currentSelectionRange = null;
      let savedSelectionRange = null;
      let activeID = 0;

      const documentNames = [
        'Documento sem título'
      ];

// Função para processar a inversão textual
function processTextInversion() {
  if (activeTabIndex < 0) return;
  
  const editor = tabs[activeTabIndex].editor;
  
  // Função para processar texto dentro de um nó
  function processTextNode(node) {
    if (node.nodeType === 3) { // Nó de texto
      let content = node.textContent;
      
      // Aplicar todas as regras de formatação
      // 1.1. Processamento de cores hexadecimais
      content = content.replace(/#([A-Fa-f0-9]{6})\s+(.*?)\s+#([A-Fa-f0-9]{6})/g, (match, startColor, text, endColor) => {
        return `<span style="color: #${startColor}">${text}</span>`;
      });
      
      // 1.2. Processamento de IDs
      content = content.replace(/\$\/(\d+)\/\$(.*?)\$\/\1\/\$/g, (match, id, text) => {
        if (id === '0') return text;
        return `<span data-id="${id}">${text}</span>`;
      });
      
      // 1.3. Processamento de negrito
      content = content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      
      // 1.4. Processamento de itálico
      content = content.replace(/\*([^*]+)\*/g, '<em>$1</em>');
      
      // 1.5. Processamento de sublinhado
      content = content.replace(/_([^_]+)_/g, '<u>$1</u>');
      
      // 1.6. Processamento de texto riscado
      content = content.replace(/-([^-]+)-/g, '<strike>$1</strike>');
      
      // Verificar se o conteúdo foi alterado
      if (content !== node.textContent) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        
        // Substituir o nó de texto atual com o conteúdo formatado
        const fragment = document.createDocumentFragment();
        while (tempDiv.firstChild) {
          fragment.appendChild(tempDiv.firstChild);
        }
        
        node.parentNode.replaceChild(fragment, node);
      }
    } else if (node.nodeType === 1) { // Elemento
      // Processar font tags com atributo color
      if (node.tagName === 'FONT' && node.hasAttribute('color')) {
        const colorValue = node.getAttribute('color');
        // Extrair o código hex da cor (remover o # se presente)
        const hexColor = colorValue.startsWith('#') ? colorValue.substring(1) : colorValue;
        
        // Substituir a tag font por um span com o texto formatado
        const spanElement = document.createElement('span');
        spanElement.style.color = colorValue;
        
        // Transferir o conteúdo
        while (node.firstChild) {
          spanElement.appendChild(node.firstChild);
        }
        
        node.parentNode.replaceChild(spanElement, node);
        return; // Não precisamos processar os filhos, pois eles foram movidos
      }
      
      // Processar spans com estilo de cor
      if (node.tagName === 'SPAN' && node.style && node.style.color) {
        // A formatação já está aplicada, não precisamos fazer nada especial aqui
      }
      
      // Processar recursivamente os filhos do elemento
      Array.from(node.childNodes).forEach(child => processTextNode(child));
    }
  }
  
  // Processar cada nó filho do editor
  Array.from(editor.childNodes).forEach(child => processTextNode(child));
  
  updateTabContent();
  updateIDHighlighting();
}

// Função para copiar texto formatado
function copyFormattedText() {
  if (activeTabIndex < 0) return;
  
  const editor = tabs[activeTabIndex].editor;
  let content = editor.innerHTML;
  
  // Converte formatações HTML para formato de texto
  
  // Converte tags <font color="...">
  content = content.replace(/<font color="([^"]+)">(.*?)<\/font>/g, (match, color, text) => {
    const hexColor = color.startsWith('#') ? color : rgbToHex(color);
    return `${hexColor} ${text} ${hexColor}`;
  });
  
  // Converte cores em spans
  content = content.replace(/<span style="color:\s*([^"]+)">(.*?)<\/span>/g, (match, color, text) => {
    const hexColor = color.startsWith('#') ? color : rgbToHex(color);
    return `${hexColor} ${text} ${hexColor}`;
  });
  
  // Converte IDs
  content = content.replace(/<span data-id="(\d+)"[^>]*>(.*?)<\/span>/g, (match, id, text) => {
    return `$/${id}/$ ${text} $/${id}/$`;
  });
  
  // Converte negrito
  content = content.replace(/<(strong|b)>(.*?)<\/\1>/g, '**$2**');
  
  // Converte itálico
  content = content.replace(/<(em|i)>(.*?)<\/\1>/g, '*$2*');
  
  // Converte sublinhado
  content = content.replace(/<u>(.*?)<\/u>/g, '_$1_');
  
  // Converte riscado
  content = content.replace(/<(strike|del)>(.*?)<\/\1>/g, '-$2-');
  
  // Remove tags HTML remanescentes
  content = content.replace(/<[^>]+>/g, '');
  
  // Copia para a área de transferência
  navigator.clipboard.writeText(content).then(() => {
    // Feedback visual
    const copyBtn = document.getElementById('copy-formatted-btn');
    copyBtn.style.backgroundColor = 'var(--accent-color)';
    setTimeout(() => copyBtn.style.backgroundColor = '', 200);
  });
}

// Função auxiliar para converter RGB para Hex
function rgbToHex(rgb) {
  const values = rgb.match(/\d+/g);
  if (!values) return '#000000';
  return '#' + values.map(x => {
    const hex = parseInt(x).toString(16);
    return hex.length === 1 ? '0' + hex : hex;
  }).join('');
}

// Adiciona os event listeners para os novos botões
document.getElementById('text-inversion-btn').addEventListener('click', processTextInversion);
document.getElementById('copy-formatted-btn').addEventListener('click', copyFormattedText);

      // Função otimizada para criar números de linha
function createLineNumbers(editor) {
  let lineNumbersDiv = editor.previousElementSibling;
  if (!lineNumbersDiv || !lineNumbersDiv.classList.contains('line-numbers')) {
    lineNumbersDiv = document.createElement('div');
    lineNumbersDiv.className = 'line-numbers';
    editor.parentNode.insertBefore(lineNumbersDiv, editor);
  }

  // Determina quais linhas estão visíveis na viewport
  const editorRect = editor.getBoundingClientRect();
  const lineHeight = 24; // altura de cada linha em pixels
  const visibleStartLine = Math.floor(editor.scrollTop / lineHeight);
  const visibleEndLine = visibleStartLine + Math.ceil(editorRect.height / lineHeight);
  
  // Adiciona um buffer para suavizar a rolagem
  const bufferSize = 50;
  const startLine = Math.max(0, visibleStartLine - bufferSize);
  const totalLines = editor.innerText.split('\n').length;
  const endLine = Math.min(totalLines + 30, visibleEndLine + bufferSize);
  
  // Otimiza a renderização criando apenas os números de linha visíveis
  // e um buffer razoável acima e abaixo
  if (lineNumbersDiv._lastStart === startLine && 
      lineNumbersDiv._lastEnd === endLine && 
      lineNumbersDiv._lastTotal === totalLines) {
    return; // Evita re-renderização se nada mudou
  }
  
  // Armazena o último estado para evitar renderizações desnecessárias
  lineNumbersDiv._lastStart = startLine;
  lineNumbersDiv._lastEnd = endLine;
  lineNumbersDiv._lastTotal = totalLines;

  // Usa DocumentFragment para melhorar performance
  const fragment = document.createDocumentFragment();
  for (let i = startLine + 1; i <= endLine; i++) {
    const lineNumber = document.createElement('div');
    lineNumber.className = 'line-number';
    lineNumber.textContent = i;
    lineNumber.style.position = 'absolute';
    lineNumber.style.top = `${(i - 1) * lineHeight}px`;
    fragment.appendChild(lineNumber);
  }
  
  // Limpa e insere os novos números de linha
  lineNumbersDiv.innerHTML = '';
  lineNumbersDiv.appendChild(fragment);
  
  // Define a altura total do container de números de linha
  lineNumbersDiv.style.height = `${Math.max(totalLines * lineHeight, editor.scrollHeight)}px`;
}

// Função melhorada para sincronizar rolagem de números de linha
function syncLineNumbersScroll(e) {
  if (!showLineNumbers) return;
  const editor = e.target;
  const lineNumbersDiv = editor.previousElementSibling;
  if (lineNumbersDiv && lineNumbersDiv.classList.contains('line-numbers')) {
    // Apenas atualiza a posição visual sem recriar todos os números
    lineNumbersDiv.style.transform = `translateY(${-editor.scrollTop}px)`;
    
    // Periodicamente recria os números visíveis para manter sincronização
    if (!lineNumbersDiv._scrollTimer) {
      lineNumbersDiv._scrollTimer = setTimeout(() => {
        createLineNumbers(editor);
        lineNumbersDiv._scrollTimer = null;
      }, 100); // Throttle para evitar múltiplas execuções
    }
  }
}

// Função aprimorada para posicionar o popup de formatação
function handleTextSelection(e) {
  const selection = window.getSelection();
  
  if (selection.rangeCount > 0 && !selection.isCollapsed) {
    currentSelectionRange = selection.getRangeAt(0).cloneRange();
    const range = selection.getRangeAt(0);
    const rect = range.getBoundingClientRect();
    
    // Dimensões e margens
    const popupWidth = formatPopup.offsetWidth || 200; // estimativa inicial se não renderizado
    const popupHeight = formatPopup.offsetHeight || 200;
    const margin = 20; // margem de segurança
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const editorRect = tabs[activeTabIndex].editor.getBoundingClientRect();
    
    // Exibe o popup para poder calcular suas dimensões corretas
    formatPopup.style.display = 'block';
    formatPopup.style.visibility = 'hidden'; // Temporariamente invisível para cálculos
    
    // Obtém dimensões reais após renderização
    const actualPopupWidth = formatPopup.offsetWidth;
    const actualPopupHeight = formatPopup.offsetHeight;
    
    // Calcula posição horizontal ideal
    let leftPos = rect.left + window.scrollX;
    if (leftPos + actualPopupWidth + margin > viewportWidth) {
      leftPos = Math.max(margin, viewportWidth - actualPopupWidth - margin);
    }
    
    // Calcula posição vertical inteligente
    let topPos;
    const spaceAbove = rect.top - editorRect.top;
    const spaceBelow = editorRect.bottom - rect.bottom;
    
    // Determina a melhor posição vertical com base no espaço disponível
    if (spaceBelow >= actualPopupHeight + margin) {
      // Suficiente espaço abaixo
      topPos = rect.bottom + window.scrollY + margin;
    } else if (spaceAbove >= actualPopupHeight + margin) {
      // Suficiente espaço acima
      topPos = rect.top + window.scrollY - actualPopupHeight - margin;
    } else {
      // Nem acima nem abaixo tem espaço ideal, encontra posição de meio termo
      const centerOffset = (viewportHeight - actualPopupHeight) / 2;
      topPos = Math.max(
        editorRect.top + margin,
        Math.min(rect.top + window.scrollY - actualPopupHeight/2, 
                editorRect.bottom - actualPopupHeight - margin)
      );
    }
    
    // Aplica posição calculada e torna visível
    formatPopup.style.left = `${leftPos}px`;
    formatPopup.style.top = `${topPos}px`;
    formatPopup.style.visibility = 'visible';
    
  } else {
    if (e && e.type === 'mouseup' &&
        !formatPopup.contains(e.target) &&
        e.target !== colorPicker &&
        e.target !== idInput) {
      formatPopup.style.display = 'none';
    }
  }
}

// Otimizações para o listener de input do editor
function optimizedEditorInputHandler() {
  updateTabContent();
  
  if (showLineNumbers) {
    // Usa um debounce para evitar múltiplas atualizações em sequência
    clearTimeout(this._inputTimer);
    this._inputTimer = setTimeout(() => {
      createLineNumbers(this);
    }, 100);
  }


// Modificação no código de inicialização para usar as funções otimizadas
function setupEditorEventListeners(editor) {
  editor.addEventListener('input');
  editor.addEventListener('scroll', function(e) {
    // Usa requestAnimationFrame para sincronizar com o ciclo de renderização
    if (!this._scrollRAF) {
      this._scrollRAF = requestAnimationFrame(() => {
        syncLineNumbersScroll(e);
        this._scrollRAF = null;
      });
    }
  });
}
}

      function handleTextClick(e) {
        const target = e.target;
        const selection = window.getSelection();
        
        if (selection.isCollapsed &&
            !formatPopup.contains(e.target) &&
            e.target !== colorPicker &&
            e.target !== idInput) {
          formatPopup.style.display = 'none';
        }

        if (target.tagName === 'SPAN' && target.hasAttribute('data-id')) {
          const clickedId = parseInt(target.getAttribute('data-id'), 10);
          activeID = clickedId;
          updateIDDisplay();
          updateIDHighlighting();
        } else if (target === e.currentTarget && selection.isCollapsed) {
          activeID = 0;
          updateIDDisplay();
          updateIDHighlighting();
        }
      }

      function applyFormatting(command, value = null) {
        let selectionToUse = currentSelectionRange;

        if (!selectionToUse && command === 'foreColor' && savedSelectionRange) {
          selectionToUse = savedSelectionRange;
        }

        if (!selectionToUse) return;

        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(selectionToUse);

        if (command === 'createSpan') {
          const id = value;
          const range = selection.getRangeAt(0);
          let currentNode = range.commonAncestorContainer;
          let parentSpans = [];

          while (currentNode && currentNode !== tabs[activeTabIndex].editor) {
            if (currentNode.nodeType === 1 && currentNode.tagName === 'SPAN' && currentNode.hasAttribute('data-id')) {
              parentSpans.push(currentNode);
            }
            currentNode = currentNode.parentNode;
          }

          if (parentSpans.length > 0) {
            let innerSpan = parentSpans[0];
            innerSpan.setAttribute('data-id', id);
            innerSpan.classList.remove('faded', 'normal');
            innerSpan.classList.add(id == activeID ? 'normal' : 'faded');
          } else {
            const selectedContent = range.extractContents();
            const span = document.createElement('span');
            span.appendChild(selectedContent);
            span.setAttribute('data-id', id);
            span.classList.add(id == activeID ? 'normal' : 'faded');
            range.insertNode(span);
            mergeAdjacentSpans(tabs[activeTabIndex].editor);
          }

          activeID = parseInt(id, 10);
          updateIDDisplay();
          updateIDHighlighting();
        } else if (['fontName', 'fontSize', 'foreColor'].includes(command)) {
          document.execCommand(command, false, value);
        } else {
          document.execCommand(command, false, null);
        }

        updateTabContent();

        const newSelection = window.getSelection();
        if (newSelection.rangeCount > 0) {
          currentSelectionRange = newSelection.getRangeAt(0).cloneRange();
          const currentRange = newSelection.getRangeAt(0);
          selection.removeAllRanges();
          selection.addRange(currentRange);
        }
      }

      function mergeAdjacentSpans(container) {
        container.normalize();
        const spans = Array.from(container.querySelectorAll('span[data-id]'));

        for (let i = 0; i < spans.length; i++) {
          const currentSpan = spans[i];
          let parent = currentSpan.parentNode;
          
          while (parent && parent !== container) {
            if (parent.tagName === 'SPAN' && parent.hasAttribute('data-id')) {
              while (currentSpan.firstChild) {
                parent.insertBefore(currentSpan.firstChild, currentSpan);
              }
              parent.removeChild(currentSpan);
              break;
            }
            parent = parent.parentNode;
          }
        }
      }

      function updateTabContent() {
        if (activeTabIndex >= 0) {
          tabs[activeTabIndex].content = tabs[activeTabIndex].editor.innerHTML;
        }
      }

      function updateIDDisplay() {
        currentIdDisplay.textContent = `ID: ${activeID}`;
      }

      function updateIDHighlighting() {
        if (activeTabIndex < 0) return;

        const editor = tabs[activeTabIndex].editor;
        const allSpans = editor.querySelectorAll('span[data-id]');

        allSpans.forEach(span => {
          span.classList.remove('faded', 'normal');
          const spanId = parseInt(span.getAttribute('data-id'), 10);

          if (spanId === 0 || spanId === activeID) {
            span.classList.add('normal');
          } else {
            span.classList.add('faded');
          }
        });
      }

      function trackCursorPosition() {
        setTimeout(() => {
          const selection = window.getSelection();
          if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const preCaretRange = range.cloneRange();

            if (activeTabIndex >= 0 && tabs[activeTabIndex].editor) {
              preCaretRange.selectNodeContents(tabs[activeTabIndex].editor);
              preCaretRange.setEnd(range.endContainer, range.endOffset);
              const text = preCaretRange.toString();

              const lines = text.split('\n');
              const line = lines.length;
              const col = lines[lines.length - 1].length + 1;

              cursorPosition.textContent = `Ln: ${line}, Col: ${col}`;
            }
          }
        }, 0);
      }

      function checkCursorInID() {
        if (activeTabIndex < 0) return;

        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          let node = range.startContainer;
          let parentWithID = null;

          if (node.nodeType === 3) {
            node = node.parentNode;
          }

          while (node && node !== tabs[activeTabIndex].editor) {
            if (node.nodeType === 1 && node.tagName === 'SPAN' && node.hasAttribute('data-id')) {
              parentWithID = node;
              break;
            }
            node = node.parentNode;
          }

          if (parentWithID) {
            const newID = parseInt(parentWithID.getAttribute('data-id'), 10);
            if (newID !== activeID) {
              activeID = newID;
              updateIDDisplay();
              updateIDHighlighting();
            }
          } else if (!formatPopup.contains(document.activeElement)) {
            if (activeID !== 0) {
              activeID = 0;
              updateIDDisplay();
              updateIDHighlighting();
            }
          }
        }
      }

      function createNewTab() {
        const tabIndex = tabs.length;
        const tabName = documentNames[Math.floor(Math.random() * documentNames.length)];

        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.innerHTML = `
          <div class="tab-title">
            <span class="tab-title-text">${tabName}</span>
            <input type="text" class="tab-title-editable" value="${tabName}" style="display: none;">
          </div>
          <div class="close-tab">✕</div>
        `;
        tabsContainer.appendChild(tab);

        tab.addEventListener('click', (e) => {
          if (!e.target.classList.contains('close-tab') &&
              !e.target.classList.contains('tab-title-editable')) {
            setActiveTab(tabIndex);
          }
        });

        const tabTitleText = tab.querySelector('.tab-title-text');
        const tabTitleInput = tab.querySelector('.tab-title-editable');

        tabTitleText.addEventListener('dblclick', () => {
          tabTitleText.style.display = 'none';
          tabTitleInput.style.display = 'inline-block';
          tabTitleInput.focus();
          tabTitleInput.select();
        });

        tabTitleInput.addEventListener('blur', () => {
          finishTabRename(tabIndex, tabTitleInput, tabTitleText);
        });

        tabTitleInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            finishTabRename(tabIndex, tabTitleInput, tabTitleText);
          } else if (e.key === 'Escape') {
            e.preventDefault();
            tabTitleInput.value = tabs[tabIndex].title;
            tabTitleText.style.display = 'inline';
            tabTitleInput.style.display = 'none';
          }
        });

        tab.querySelector('.close-tab').addEventListener('click', (e) => {
          e.stopPropagation();
          closeTab(tabIndex);
        });

        const editor = document.createElement('div');
        editor.className = 'editor';
        if (showLineNumbers) {
          editor.classList.add('editor-with-line-numbers');
        }
        editor.contentEditable = true;
        editor.placeholder = 'Digite seu texto aqui...';
        editor.dataset.tabIndex = tabIndex;
        editorContainer.appendChild(editor);

        editor.addEventListener('input', () => {
  updateTabContent();
  if (showLineNumbers) {
    const content = editor.innerText;
    const currentLines = content.split('\n').length;
    const lineNumbersDiv = editor.previousElementSibling;
    
    if (lineNumbersDiv && lineNumbersDiv.classList.contains('line-numbers')) {
      const existingLines = lineNumbersDiv.children.length;
      if (currentLines + 100 > existingLines) {
        createLineNumbers(editor);
      }
    }
  }
        });
        editor.addEventListener('mouseup', handleTextSelection);
        editor.addEventListener('keyup', handleTextSelection);
        editor.addEventListener('click', handleTextClick);
        editor.addEventListener('keydown', trackCursorPosition);
        editor.addEventListener('click', trackCursorPosition);
        editor.addEventListener('focus', updateIDHighlighting);
        editor.addEventListener('keyup', checkCursorInID);
        editor.addEventListener('mouseup', checkCursorInID);
        editor.addEventListener('scroll', syncLineNumbersScroll);
        editor.addEventListener('keydown', function(e) {
          if (e.key === 'Tab') {
            e.preventDefault();
            document.execCommand('insertHTML', false, '&nbsp;&nbsp;&nbsp;&nbsp;');
            updateTabContent();
          }
        });

        tabs.push({
          element: tab,
          editor: editor,
          title: tabName,
          content: ''
        });

        if (showLineNumbers) {
          createLineNumbers(editor);
        }

        setActiveTab(tabIndex);
        return tabIndex;
      }

      function finishTabRename(tabIndex, inputElement, textElement) {
        const newTitle = inputElement.value.trim() || documentNames[0];
        textElement.textContent = newTitle;
        tabs[tabIndex].title = newTitle;
        textElement.style.display = 'inline';
        inputElement.style.display = 'none';
      }

      function setActiveTab(index) {
        if (index >= 0 && index < tabs.length) {
          if (activeTabIndex >= 0 && activeTabIndex < tabs.length) {
            tabs[activeTabIndex].element.classList.remove('active');
            tabs[activeTabIndex].editor.classList.remove('active');
          }

          tabs[index].element.classList.add('active');
          tabs[index].editor.classList.add('active');
          activeTabIndex = index;

          if (showLineNumbers) {
            createLineNumbers(tabs[index].editor);
          }

          tabs[index].editor.focus();
          updateIDDisplay();
          updateIDHighlighting();
        }
      }

      function closeTab(index) {
        if (tabs.length <= 1) {
          tabs[0].editor.innerHTML = '';
          tabs[0].content = '';
          return;
        }

        if (showLineNumbers) {
          const lineNumbersDiv = tabs[index].editor.previousElementSibling;
          if (lineNumbersDiv && lineNumbersDiv.classList.contains('line-numbers')) {
            lineNumbersDiv.remove();
          }
        }

        tabs[index].element.remove();
        tabs[index].editor.remove();
        tabs.splice(index, 1);

        tabs.forEach((tab, i) => {
          tab.editor.dataset.tabIndex = i;
          tab.element.querySelector('.close-tab').onclick = (e) => {
            e.stopPropagation();
            closeTab(i);
          };

          tab.element.onclick = (e) => {
            if (!e.target.classList.contains('close-tab') &&
                !e.target.classList.contains('tab-title-editable')) {
              setActiveTab(i);
            }
          };
        });

        if (activeTabIndex >= index) {
          activeTabIndex = Math.max(0, activeTabIndex - 1);
        }

        setActiveTab(activeTabIndex);

      }

      // Event Listeners
      colorPicker.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          savedSelectionRange = selection.getRangeAt(0).cloneRange();
        }
      });

      colorPicker.addEventListener('input', (e) => {
        if (savedSelectionRange) {
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(savedSelectionRange);
          applyFormatting('foreColor', colorPicker.value);
        }
      });

      idInput.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        if (currentSelectionRange) {
          savedSelectionRange = currentSelectionRange.cloneRange();
        }
      });

      idInput.addEventListener('change', () => {
        const id = idInput.value || '0';
        if (savedSelectionRange) {
          currentSelectionRange = savedSelectionRange;
        }
        applyFormatting('createSpan', id);
      });

      idInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          applyFormatting('createSpan', idInput.value || '0');
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          idInput.value = parseInt(idInput.value || '0') + 1;
        } else if (e.key === 'ArrowDown') {
          e.preventDefault();
          idInput.value = Math.max(0, parseInt(idInput.value || '0') - 1);
        }
      });

      idInput.addEventListener('click', (e) => {
        e.stopPropagation();
      });

      boldBtn.addEventListener('click', () => applyFormatting('bold'));
      italicBtn.addEventListener('click', () => applyFormatting('italic'));
      underlineBtn.addEventListener('click', () => applyFormatting('underline'));

      fontSelect.addEventListener('change', () => {
        applyFormatting('fontName', fontSelect.value);
      });

      sizeSelect.addEventListener('change', () => {
        applyFormatting('fontSize', sizeSelect.value);
      });

      function toggleLineNumbers() {
        showLineNumbers = !showLineNumbers;
        tabs.forEach(tab => {
          if (showLineNumbers) {
            tab.editor.classList.add('editor-with-line-numbers');
            createLineNumbers(tab.editor);
          } else {
            tab.editor.classList.remove('editor-with-line-numbers');
            const lineNumbersDiv = tab.editor.previousElementSibling;
            if (lineNumbersDiv && lineNumbersDiv.classList.contains('line-numbers')) {
              lineNumbersDiv.remove();
            }
          }
        });
      }

      lineNumbersBtn.addEventListener('click', toggleLineNumbers);

      document.addEventListener('click', (e) => {
        if (!formatPopup.contains(e.target) &&
            e.target !== formatPopup &&
            e.target !== colorPicker &&
            e.target !== idInput) {
          const selection = window.getSelection();
          if (selection.isCollapsed) {
            formatPopup.style.display = 'none';
          }
        }
      });

      window.addEventListener('beforeunload', (e) => {
        if (tabs.some(tab => tab.content.length > 0)) {
          e.preventDefault();
          e.returnValue = '';
        }
      });

      // Initialize with first tab
      createNewTab();
    });
  </script>
</body>
</html>